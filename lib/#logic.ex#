defmodule Logic do
  def gate(Gate, InputNode, OutputNode) do
    case Gate do
      :and ->
        receive do
          {A, B} ->
            send(OutputNode, A and B)
            gate(:and, InputNode, OutputNode)
        end
      :nand ->
        receive do
          {A, B} ->
            send(OutputNode, not(A and B))
            gate(:nand, InputNode, OutputNode)
        end
      :or ->
        receive do
          {A, B} ->
            send(OutputNode, A or B)
            gate(:or, InputNode, OutputNode)
        end
      :nor ->
        receive do
          {A, B} ->
            send(OutputNode, not(A or B))
            gate(:nor, InputNode, OutputNode)
        end
      :xor ->
        receive do
          {A, B} ->
            send(OutputNode, A xor B)
            gate(:xor, InputNode, OutputNode)
        end
      :xnor ->
        receive do
          {A, B} ->
            send(OutputNode, not(A xor B))
            gate(:xnor, InputNode, OutputNode)
        end
      :not ->
        receive do
          In ->
            send(OutputNode, not(In))
            gate(:not, InputNode, OutputNode)
        end
      :buffer ->
        receive do
          In ->
            send(OutputNode, In)
            gate(:buffer, InputNode, OutputNode)
        end
    end
  end

  def node(Name, ConnList) do
    nodeName = Name
    receive do
      {:getName, Source} ->
        send(Source, nodeName)
        node(Name, ConnList)
      {:connectItem, Item} ->
        node(Name, [Item | ConnList])
      In ->
        Manifold.send(ConnList, In)
        node(Name, ConnList)
    end
  end
end